class wires {
    new tags.item(rods) {
    "replace": false,
        "values": [
            "minecraft:end_rod",
            "minecraft:lightning_rod",
            { "id": "minecraft:waxed_lightning_rod", "required": false },
            { "id": "minecraft:exposed_lightning_rod", "required": false },
            { "id": "minecraft:oxidized_lightning_rod", "required": false },
            { "id": "minecraft:weathered_lightning_rod", "required": false },
            { "id": "minecraft:waxed_exposed_lightning_rod", "required": false },
            { "id": "minecraft:waxed_oxidized_lightning_rod", "required": false },
            { "id": "minecraft:waxed_weathered_lightning_rod", "required": false }
        ]
    }

    new tags.item(bulbs) {
        "replace": false,
            "values": [
                "minecraft:copper_bulb",
                "minecraft:waxed_copper_bulb",
                "minecraft:exposed_copper_bulb",
                "minecraft:oxidized_copper_bulb",
                "minecraft:weathered_copper_bulb",
                "minecraft:waxed_exposed_copper_bulb",
                "minecraft:waxed_oxidized_copper_bulb",
                "minecraft:waxed_weathered_copper_bulb"
            ]
    }

    new tags.item(grates) {
        "replace": false,
            "values": [
                "minecraft:copper_grate",
                "minecraft:waxed_copper_grate",
                "minecraft:exposed_copper_grate",
                "minecraft:oxidized_copper_grate",
                "minecraft:weathered_copper_grate",
                "minecraft:waxed_exposed_copper_grate",
                "minecraft:waxed_oxidized_copper_grate",
                "minecraft:waxed_weathered_copper_grate"            
            ]
    }

    new tags.item(stairs) {
        "replace": false,
            "values": [
                "minecraft:cut_copper_stairs",
                "minecraft:waxed_cut_copper_stairs",
                "minecraft:exposed_cut_copper_stairs",
                "minecraft:oxidized_cut_copper_stairs",
                "minecraft:weathered_cut_copper_stairs",
                "minecraft:waxed_exposed_cut_copper_stairs",
                "minecraft:waxed_oxidized_cut_copper_stairs",
                "minecraft:waxed_weathered_cut_copper_stairs",
                "minecraft:smooth_quartz_stairs",
                "minecraft:quartz_stairs"
            ]
    }

    new tags.item(modifiable)  {
        "replace": false,
            "values": [
                "minecraft:cut_copper_stairs",
                "minecraft:waxed_cut_copper_stairs",
                "minecraft:exposed_cut_copper_stairs",
                "minecraft:oxidized_cut_copper_stairs",
                "minecraft:weathered_cut_copper_stairs",
                "minecraft:waxed_exposed_cut_copper_stairs",
                "minecraft:waxed_oxidized_cut_copper_stairs",
                "minecraft:waxed_weathered_cut_copper_stairs",

                "minecraft:end_rod",
                "minecraft:lightning_rod",
                { "id": "minecraft:waxed_lightning_rod", "required": false },
                { "id": "minecraft:exposed_lightning_rod", "required": false },
                { "id": "minecraft:oxidized_lightning_rod", "required": false },
                { "id": "minecraft:weathered_lightning_rod", "required": false },
                { "id": "minecraft:waxed_exposed_lightning_rod", "required": false },
                { "id": "minecraft:waxed_oxidized_lightning_rod", "required": false },
                { "id": "minecraft:waxed_weathered_lightning_rod", "required": false }
            ]
    }

    new tags.item(special_blocks) {
        "replace": false,
            "values": [
                "minecraft:cut_copper_stairs",
                "minecraft:waxed_cut_copper_stairs",
                "minecraft:exposed_cut_copper_stairs",
                "minecraft:oxidized_cut_copper_stairs",
                "minecraft:weathered_cut_copper_stairs",
                "minecraft:waxed_exposed_cut_copper_stairs",
                "minecraft:waxed_oxidized_cut_copper_stairs",
                "minecraft:waxed_weathered_cut_copper_stairs",
                "minecraft:smooth_quartz_stairs",
                "minecraft:quartz_stairs",
                

                "minecraft:end_rod",
                "minecraft:lightning_rod",
                { "id": "minecraft:waxed_lightning_rod", "required": false },
                { "id": "minecraft:exposed_lightning_rod", "required": false },
                { "id": "minecraft:oxidized_lightning_rod", "required": false },
                { "id": "minecraft:weathered_lightning_rod", "required": false },
                { "id": "minecraft:waxed_exposed_lightning_rod", "required": false },
                { "id": "minecraft:waxed_oxidized_lightning_rod", "required": false },
                { "id": "minecraft:waxed_weathered_lightning_rod", "required": false },

                "minecraft:copper_grate",
                "minecraft:waxed_copper_grate",
                "minecraft:exposed_copper_grate",
                "minecraft:oxidized_copper_grate",
                "minecraft:weathered_copper_grate",
                "minecraft:waxed_exposed_copper_grate",
                "minecraft:waxed_oxidized_copper_grate",
                "minecraft:waxed_weathered_copper_grate",

                "minecraft:copper_bulb",
                "minecraft:waxed_copper_bulb",
                "minecraft:exposed_copper_bulb",
                "minecraft:oxidized_copper_bulb",
                "minecraft:weathered_copper_bulb",
                "minecraft:waxed_exposed_copper_bulb",
                "minecraft:waxed_oxidized_copper_bulb",
                "minecraft:waxed_weathered_copper_bulb",

                "minecraft:sea_lantern",
                "minecraft:redstone_lamp"
            ]
    }
}

class place_uielement {
    new advancement(single) {
        "criteria": {
            "used_interaction": {
                "trigger": "minecraft:player_interacted_with_entity",
                    "conditions": {
                    "player": [
                        {
                            "condition": "minecraft:all_of",
                            "terms": [
                                {
                                    "condition": "minecraft:entity_properties",
                                    "entity": "this",
                                    "predicate": {
                                        "type_specific": {
                                            "type": "minecraft:player",
                                            "input": {
                                                "sprint": false
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    ],
                        "entity": {
                        "type": "minecraft:interaction",
                        "nbt": "{Tags:[\"lg.uiHitbox\"]}"
                    }
                }
            }
        },
        "requirements": [
            [
                "used_interaction"
            ]
        ],
            "rewards": {
            "function": "mclg:zzz_/ui/place/single"
        }
    }

    new advancement(fill) {
        "criteria": {
            "used_interaction": {
                "trigger": "minecraft:player_interacted_with_entity",
                    "conditions": {
                    "player": [
                        {
                            "condition": "minecraft:all_of",
                            "terms": [
                                {
                                    "condition": "minecraft:entity_properties",
                                    "entity": "this",
                                    "predicate": {
                                        "type_specific": {
                                            "type": "minecraft:player",
                                            "input": {
                                                "sprint": true
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    ],
                        "entity": {
                        "type": "minecraft:interaction",
                        "nbt": "{Tags:[\"lg.uiHitbox\"]}"
                    }
                }
            }
        },
        "requirements": [
            [
                "used_interaction"
            ]
        ],
            "rewards": {
            "function": "mclg:zzz_/ui/place/fill"
        }
    }

    new predicate(at_current_cell) {
    "condition": "minecraft:entity_scores",
        "entity": "this",
        "scores": {
            "__pos0__": {
                "min": {
                    "type": "minecraft:score",
                        "target": {
                        "type": "minecraft:fixed",
                        "name": "$x"
                    },
                    "score": "__variable__"
                },
                "max": {
                    "type": "minecraft:score",
                        "target": {
                        "type": "minecraft:fixed",
                            "name": "$x"
                    },
                    "score": "__variable__"
                }
            },
            "__pos1__": {
                "min": {
                    "type": "minecraft:score",
                        "target": {
                        "type": "minecraft:fixed",
                        "name": "$y"
                    },
                    "score": "__variable__"
                },
                "max": {
                    "type": "minecraft:score",
                        "target": {
                        "type": "minecraft:fixed",
                        "name": "$y"
                    },
                    "score": "__variable__"
                }
            },
            "__pos2__": {
                "min": {
                    "type": "minecraft:score",
                        "target": {
                        "type": "minecraft:fixed",
                        "name": "$z"
                    },
                    "score": "__variable__"
                },
                "max": {
                    "type": "minecraft:score",
                        "target": {
                        "type": "minecraft:fixed",
                        "name": "$z"
                    },
                    "score": "__variable__"
                }
            }
        }
    }

    new predicate(between_rp) {
    "condition": "minecraft:entity_scores",
        "entity": "this",
        "scores": {
            "__pos0__": {
                "min": {
                    "type": "minecraft:score",
                        "target": {
                        "type": "minecraft:fixed",
                        "name": "$min_x"
                    },
                    "score": "__variable__"
                },
                "max": {
                    "type": "minecraft:score",
                        "target": {
                        "type": "minecraft:fixed",
                            "name": "$max_x"
                    },
                    "score": "__variable__"
                }
            },
            "__pos1__": {
                "min": {
                    "type": "minecraft:score",
                        "target": {
                        "type": "minecraft:fixed",
                        "name": "$min_y"
                    },
                    "score": "__variable__"
                },
                "max": {
                    "type": "minecraft:score",
                        "target": {
                        "type": "minecraft:fixed",
                        "name": "$max_y"
                    },
                    "score": "__variable__"
                }
            },
            "__pos2__": {
                "min": {
                    "type": "minecraft:score",
                        "target": {
                        "type": "minecraft:fixed",
                        "name": "$min_z"
                    },
                    "score": "__variable__"
                },
                "max": {
                    "type": "minecraft:score",
                        "target": {
                        "type": "minecraft:fixed",
                        "name": "$max_z"
                    },
                    "score": "__variable__"
                }
            }
        }
    }
}

// Initliaze ui element info
if (!data storage mclg:ui element_info) {
        ui:: += {
        element_info:
        {
            rod: {
                0: {
                    lightning_rod_facing: "up",
                    end_rod_facing: "down",
                    display: "North to South",
                    tags: [
                        "lg.uiElement",
                        "lg.can_rotate",
                        "lg.wire",
                        "lg.rod",
                        "lg.nts"
                    ]
                },
                1: {
                    lightning_rod_facing: "west",
                    end_rod_facing: "east",
                    display: "West to East",
                    tags: [
                        "lg.uiElement",
                        "lg.can_rotate",
                        "lg.wire",
                        "lg.rod",
                        "lg.etw"
                    ]
                },
                2: {
                    lightning_rod_facing: "down",
                    end_rod_facing: "up",
                    display: "South to North",
                    tags: [
                        "lg.uiElement",
                        "lg.can_rotate",
                        "lg.wire",
                        "lg.rod",
                        "lg.stn"
                    ]
                },
                3: {
                    lightning_rod_facing: "east",
                    end_rod_facing: "west",
                    display: "East to West",
                    tags: [
                        "lg.uiElement",
                        "lg.can_rotate",
                        "lg.wire",
                        "lg.rod",
                        "lg.wte"
                    ]
                }
                
            },
            stair: {
                0: {
                    display: "North, West",
                    facing: "west",
                    half: "bottom",
                    tags: [
                        "lg.can_rotate",
                        "lg.uiElement",
                        "lg.stair",
                        "lg.wire",
                        "lg.in_n",
                        "lg.in_w"
                    ]
                },
                1: {
                    display: "North, East",
                    facing: "east",
                    half: "bottom",
                    tags: [
                        "lg.can_rotate",
                        "lg.uiElement",
                        "lg.stair",
                        "lg.wire",
                        "lg.in_n",
                        "lg.in_e"
                    ]
                },
                2: {
                    display: "South, West",
                    facing: "west",
                    half: "top",
                    tags: [
                        "lg.can_rotate",
                        "lg.uiElement",
                        "lg.stair",
                        "lg.wire",
                        "lg.in_s",
                        "lg.in_w"
                    ]
                },
                3: {
                    display: "South, East",
                    facing: "east",
                    half: "top",
                    tags: [
                        "lg.can_rotate",
                        "lg.uiElement",
                        "lg.stair",
                        "lg.wire",
                        "lg.in_s",
                        "lg.in_e"
                    ]
                }       
            },
            gate: {
                tags: [
                    "lg.uiElement",
                    "lg.gate_output",
                    "lg.gate",
                    "lg.hasWireId"
                ]
            }
        }
    };
}

Scoreboard.add(__wireId__); Scoreboard.add(__wireId2__);

Scoreboard.add(__gateId__);
Scoreboard.add(__gateType__); __gateType__:@a ??= 0;
Scoreboard.add(__gateOrientation__); __gateOrientation__:@a ??= 0;
Scoreboard.add(__stairRotation__); __stairRotation__:@a ??= 0;
Scoreboard.add(__rodRotation__); __rodRotation__:@a ??= 0;
Scoreboard.add(__wireType__);

Scoreboard.add(__pos0__);
Scoreboard.add(__pos1__);
Scoreboard.add(__pos2__);

Scoreboard.add(__cpp__);

Scoreboard.add(__pp0__);
Scoreboard.add(__pp1__);
Scoreboard.add(__pp2__);
Scoreboard.add(__pp3__);
Scoreboard.add(__pp4__);
Scoreboard.add(__pp5__);

class zzz_.ui.place {

    @lazy function place_fill (cmds) {

        // Set the target item to the currently held item
        ui::element_info.item = @s::SelectedItem.id;
        $id = __playerId__:@s;
        execute at _highlight_ run {
            for ($x = __pp0__:@s; $x <= __pp3__:@s; $x += 25) {
                for ($y = __pp1__:@s; $y <= __pp4__:@s; $y += 25) {
                    for ($z = __pp2__:@s; $z <= __pp5__:@s; $z += 25) {
                        
                        // Summon ui element unless there's another one in the current position
                        if (!entity @e[type=block_display,tag=lg.uiElement,distance=..250,predicate=mclg:place_uielement/at_current_cell,limit = 2]) {
                            $fillVolume++;
                            execute summon block_display run {
                                rotate @s ~ ~;

                                @s::Pos[0] = 0.01 * (float) $x;
                                @s::Pos[1] = 0.01 * (float) $y;
                                @s::Pos[2] = 0.01 * (float) $z;

                                __pos0__:@s = $x;
                                __pos1__:@s = $y;
                                __pos2__:@s = $z;

                                @s::block_state.Name = ui::element_info.item;
                                @s::transformation.scale = [0.25f, 0.25f, 0.25f];
                                JMC.call($cmds);              
                            }
                        }
                        
                    }
                }
            }
        }
    }

    @lazy function set_wireId() {
        $max = 0;
        $max > __wireId__:@e[type=block_display,tag=lg.hasWireId];
        $max > __wireId2__:@e[type=block_display,tag=lg.hasWireId];
        $max++;
        __wireId__:@s = $max;
    }

    @lazy function set_gateId() {
        $max = 0;
        $max > __gateId__:@e[type=block_display,tag=lg.gate];
        $max++;
        __gateId__:@s = $max;
    }

    @lazy function rotate.rod(rodRotation) {
        @s::Tags = ui::element_info.rod.$rodRotation.tags;
        @s::CustomName = ui::element_info.rod.$rodRotation.display;
        __rodRotation__:@s = $rodRotation;
        __wireType__:@s = 0;

        if (items entity @p[tag=lg.placing] weapon.mainhand minecraft:end_rod) {
            @s::block_state.Properties.facing = ui::element_info.rod.$rodRotation.end_rod_facing;

        } else {
            @s::block_state.Properties.facing = ui::element_info.rod.$rodRotation.lightning_rod_facing;
        }    
    }

    @lazy function apply_data.rod () {
        switch (__rodRotation__:@p[tag=lg.placing]) {
            case 0:
                this.rotate.rod(0);
            case 1:
                this.rotate.rod(1);
            case 2:
                this.rotate.rod(2);
            case 3:
                this.rotate.rod(3);
        }
        
    }
    @lazy function apply_data.stair () {
        execute run {
            __wireType__:@s = 1;
            $@s::Tags = ui::element_info.stair.$(0).tags;
            $@s::CustomName = ui::element_info.stair.$(0).display;
            $@s::block_state.Properties.half = ui::element_info.stair.$(0).half;
            $@s::block_state.Properties.facing = ui::element_info.stair.$(0).facing;
            __stairRotation__:@s = __stairRotation__:@p[tag=lg.placing];
        } with [__stairRotation__:@p[tag=lg.placing]];
        
    }
    @lazy function apply_data.bulb () {
        __wireType__:@s = 2;
        tag @s add lg.wire;
        tag @s add lg.bulb;
        tag @s add lg.uiElement;
        @s::CustomName = "Bulb";
    }
    @lazy function apply_data.grate () {
        __wireType__:@s = 3;
        tag @s add lg.wire;
        tag @s add lg.grate;
        tag @s add lg.uiElement;
        @s::CustomName = "Splitter";
    }
    @lazy function apply_data.buffer () {
        __wireType__:@s = 4;
        tag @s add lg.wire;
        tag @s add lg.buffer;
        tag @s add lg.hasWireId;
        tag @s add lg.uiElement;
        this.set_wireId();

        @s::CustomName = "Buffer";
    }
    @lazy function apply_data.general () {
        tag @s add lg.uiElement;
    }

    @lazy function apply_data.gates.vertical (wool,type) {
        summon block_display ~ ~0.25 ~ {Tags:["lg.uiElement","lg.gate","lg.gate_input","lg.gate_temp","lg.hasWireId","lg.gate_top"],transformation:{left_rotation:[0f,0f,0f,1f],right_rotation:[0f,0f,0f,1f],translation:[0f,0f,0f],scale:[0.25f,0.25f,0.25f]},block_state:{Name:"minecraft:$wool_wool"}};
        summon block_display ~ ~-0.25 ~ {Tags:["lg.uiElement","lg.gate","lg.gate_input","lg.gate_temp","lg.hasWireId","lg.gate_bottom"],transformation:{left_rotation:[0f,0f,0f,1f],right_rotation:[0f,0f,0f,1f],translation:[0f,0f,0f],scale:[0.25f,0.25f,0.25f]},block_state:{Name:"minecraft:$wool_wool"}};
        
        this.set_gateId();
        $max_gate_id = $max;
        __gateType__:@s = $type;
        execute as @e[type=block_display,sort=nearest,tag=lg.gate_temp,distance=..0.26,limit=2] run {
            __wireType__:@s = 5;
            __pos0__:@s = __pos0__:@n[type=block_display,tag=lg.gate_output,distance=..0.25];
            __pos2__:@s = __pos2__:@n[type=block_display,tag=lg.gate_output,distance=..0.25];

            if (entity @s[tag=lg.gate_top]) {
                __pos1__:@s := __pos1__:@n[type=block_display,tag=lg.gate_output,distance=..0.5] + 25;
                tag @s remove lg.gate_top;
            } else {
                __pos1__:@s := __pos1__:@n[type=block_display,tag=lg.gate_output,distance=..0.5] - 25;
                tag @s remove lg.gate_bottom;
            }

            rotate @s ~ ~;
            __gateId__:@s = $max_gate_id;
            tag @s remove lg.gate_temp;

            execute at @s run zzz_.bfs.backward.get_type();
        }
    }
    @lazy function apply_data.gates.horizontal (wool,type) {
        summon block_display ^0.25 ^ ^ {Tags:["lg.uiElement","lg.gate","lg.gate_input","lg.gate_temp","lg.hasWireId"],transformation:{left_rotation:[0f,0f,0f,1f],right_rotation:[0f,0f,0f,1f],translation:[0f,0f,0f],scale:[0.25f,0.25f,0.25f]},block_state:{Name:"minecraft:$wool_wool"}};
        summon block_display ^-0.25 ^ ^ {Tags:["lg.uiElement","lg.gate","lg.gate_input","lg.gate_temp","lg.hasWireId"],transformation:{left_rotation:[0f,0f,0f,1f],right_rotation:[0f,0f,0f,1f],translation:[0f,0f,0f],scale:[0.25f,0.25f,0.25f]},block_state:{Name:"minecraft:$wool_wool"}};
        this.set_gateId();
        $max_gate_id = $max;
        __gateType__:@s = $type;
        execute as @e[type=block_display,sort=nearest,tag=lg.gate_temp,distance=..0.26,limit=2] run {
            __wireType__:@s = 5;
            
            rotate @s ~ ~;

            __pos0__:@s = @s::Pos[0] * 100;
            __pos1__:@s = __pos1__:@n[type=block_display,tag=lg.gate_output,distance=..0.25];
            __pos2__:@s = @s::Pos[2] * 100;

            __gateId__:@s = $max_gate_id;
            tag @s remove lg.gate_temp;

            execute at @s run zzz_.bfs.backward.get_type();
        }
    }

    @lazy function chip.store_data () {
        tag @s remove lg.chip_build;
        execute if entity @s[tag=lg.starter] run tag @s remove lg.starter;
        if (!__pp0__:@p[tag=lg.saving,distance=..250] = __pp3__:@p[tag=lg.saving,distance=..250]) {
            $relPos_x := {@s::Pos[0] * 100} - $chipStart_x;
        } else {
            $relPos_x := {@s::Pos[2] * 100} - $chipStart_z;
        }
        
        $relPos_y := {@s::Pos[1] * 100} - $chipStart_y; 
        
        if ($yaw = 270 || $yaw = 180) 
        {
            $relPos_x *= -1;
        }

        chip::build.info.CustomName.del();
        chip::build.info.wireType.del();
        chip::build.info.rel_id.del();
        chip::build.info.rotation.del();
        chip::build.info.gateType.del();
        chip::build.info.connectedWireId.del();
        
        if (entity @s[tag=lg.wire] || entity @s[tag=lg.gate]) {
            chip::build.info.CustomName = @s::CustomName;
            chip::build.info.wireType = __wireType__:@s;
        }
        if (entity @s[tag=lg.hasWireId]) {

            $relId_wire_1 = __wireId__:@s;
            $relId_wire_2 = __wireId2__:@s;
            $relId_wire_1 -= $min_wireId;
            $relId_wire_2 -= $min_wireId;
            chip::build.info.rel_id.wire.1 = $relId_wire_1;
            chip::build.info.rel_id.wire.2 = $relId_wire_2;

        } 
        if (entity @s[tag=lg.gate]) {
            $relId_gate = __gateId__:@s;
            $relId_gate -= $min_gateId;
            chip::build.info.rel_id.gate = $relId_gate;
        } 

        if (entity @s[tag=lg.rod]) {
            chip::build.info.rotation = __rodRotation__:@s;
        } else if (entity @s[tag=lg.stair]) {
            chip::build.info.rotation = __stairRotation__:@s;
        } else if (entity @s[tag=lg.gate_output]) {
            chip::build.info.gateType = __gateType__:@s;

            $relId_connectedWire1 = __connectedWireId1__:@s;
            $relId_connectedWire2 = __connectedWireId2__:@s;
            $relId_connectedWire1 -= $min_wireId;
            $relId_connectedWire2 -= $min_wireId;
            chip::build.info.rel_id.connectedWire.1 = $relId_connectedWire1;
            chip::build.info.rel_id.connectedWire.2 = $relId_connectedWire2;
        } else if (entity @s[tag=lg.buffer]) {
            $relId_connectedWire1 = __connectedWireId1__:@s;
            $relId_connectedWire1 -= $min_wireId;
            chip::build.info.rel_id.connectedWire.1 = $relId_connectedWire1;
        }
        
        chip::build.info.Tags = @s::Tags;
        chip::build.info.block_state = @s::block_state;
        chip::build.info.rel_pos.x = 0.01 * (float) $relPos_x;
        chip::build.info.rel_pos.y = 0.01 * (float) $relPos_y;

        chip::build.arr >> chip::build.info;
    }

    @lazy function chip.give_item () {
        chip::build.num = $chip_num++;
        chip::build.id = $chipId;
        execute at @p[tag=lg.saving,distance=..250] run {
            summon item ~ ~ ~ {Tags:["lg.temp_item"],Item:{"id":"minecraft:bow","count":1},PickupDelay:0};
            execute as @n[type=item,tag=lg.temp_item] run {

                item replace entity @s contents from entity @p[tag=lg.saving,distance=..250] weapon.mainhand;
                $item modify entity @s contents {function:"minecraft:set_name",name:{text:"Chip_$(num)"},target:"item_name",conditions:[]};
                $item modify entity @s contents {function:"minecraft:set_custom_data",tag:{blocks:$(arr),"id":$(id),"lg.chip":1b},conditions:[]};
                chip::build.del();
            } with chip::build;
        }
    }

    function chip.build () {
        execute as @e[type=block_display,tag=lg.uiElement,tag=lg.chip_build,distance=..250,limit = 1000] run {
            $build := ($build + 1) % 1000;
            $packVolume++;
            debug({"score":{"name":"$build","objective":"__variable__"}});

            if ($build != 0) {
                this.chip.store_data();

                if ($packVolume = $recur) {
                    debug("Finished building chip");
                    this.chip.give_item();
                    tag @p[tag=lg.saving] remove lg.saving;
                }

            } else {
                debug("1000");
                this.chip.store_data();
                this.chip.give_item();
                schedule function this.chip.build() 5t replace;
            }
        }
    }

    function single() {

        $id = __playerId__:@s;
        execute at _highlight_ run {
            if (!entity _uiElement_ && !items entity @s weapon.mainhand #c:shulker_boxes && items entity @s weapon.mainhand *) {
                __cpp__:@s = -1;
                __crp__:@s = -1;
                __crop__:@s = -1;
                tag @e[type=block_display,tag=lg.uiElement,tag=lg.searched,distance=..250] remove lg.searched;
                tag @s add lg.placing;
                execute summon block_display run {
                    
                    __pos0__:@s = ui::highlightPos[0] * 100;
                    __pos1__:@s = ui::highlightPos[1] * 100;
                    __pos2__:@s = ui::highlightPos[2] * 100;

                    rotate @s ~ ~;

                    @s::block_state.Name = @p[tag=lg.placing]::SelectedItem.id;
                    @s::transformation.scale = [0.25f, 0.25f, 0.25f];

                    if (items entity @p[tag=lg.placing] weapon.mainhand #mclg:wires/rods) {
                        this.apply_data.rod();
                        zzz_.bfs.backward.get_type();

                    } else if (items entity @p[tag=lg.placing] weapon.mainhand #mclg:wires/stairs) {
                        this.apply_data.stair();
                        zzz_.bfs.backward.get_type();

                    } else if (items entity @p[tag=lg.placing] weapon.mainhand #mclg:wires/bulbs) {
                        this.apply_data.bulb();
                        zzz_.bfs.backward.get_type();
                        
                    } else if (items entity @p[tag=lg.placing] weapon.mainhand #mclg:wires/grates) {
                        this.apply_data.grate();
                        zzz_.bfs.backward.get_type();
                        
                    } else if (items entity @p[tag=lg.placing] weapon.mainhand minecraft:redstone_lamp){
                        this.apply_data.buffer();
                        $max = 0;
                        execute as @e[type=block_display,tag=lg.hasWireId] run {
                            $max > __wireId__:@s;
                            $max > __wireId2__:@s;
                        }
                        $max++;
                        __wireId2__:@s = $max;
                        zzz_.bfs.backward.get_type();
                        __output__:@s = 0;

                    } else if (items entity @p[tag=lg.placing] weapon.mainhand minecraft:sea_lantern) {
                        @s::Tags = ui::element_info.gate.tags;
                        __connectedWireId1__:@s = 0;
                        __connectedWireId2__:@s = 0;
                        __wireType__:@s = 4;
                        this.set_wireId();
                        __wireId2__:@s = __wireId__:@s;
                        switch (__gateType__:@p[tag=lg.placing]) {
                            //AND
                            case 0:
                                switch (__gateOrientation__:@p[tag=lg.placing]) {
                                    case 0:
                                        this.apply_data.gates.vertical(lime,0);
                                    case 1:
                                        this.apply_data.gates.horizontal(lime,0);
                                };
                            //NAND
                            case 1:
                                switch (__gateOrientation__:@p[tag=lg.placing]) {
                                    case 0:
                                        this.apply_data.gates.vertical(brown,1);
                                    case 1:
                                        this.apply_data.gates.horizontal(brown,1);
                                };
                            //NOR
                            case 2:
                                switch (__gateOrientation__:@p[tag=lg.placing]) {
                                    case 0:
                                        this.apply_data.gates.vertical(gray,2);
                                    case 1:
                                        this.apply_data.gates.horizontal(gray,2);
                                };
                            //NOT
                            case 3:
                                @s::block_state.Name = "red_wool";
                                tag @s add lg.gate_input;
                                __gateType__:@s = 3;
                                zzz_.bfs.backward.get_type();
                               if (!__wireId2__:@s > 0) {
                                    $max = 0;
                                    execute as @e[type=block_display,tag=lg.hasWireId] run {
                                        $max > __wireId__:@s;
                                        $max > __wireId2__:@s;
                                    }
                                    $max++;
                                    __wireId2__:@s = $max;
                                }

                            //OR
                            case 4:
                                switch (__gateOrientation__:@p[tag=lg.placing]) {
                                    case 0:
                                        this.apply_data.gates.vertical(cyan,4);
                                    case 1:
                                        this.apply_data.gates.horizontal(cyan,4);
                                };
                            //XNOR
                            case 5:
                                switch (__gateOrientation__:@p[tag=lg.placing]) {
                                    case 0:
                                        this.apply_data.gates.vertical(yellow,5);
                                    case 1:
                                        this.apply_data.gates.horizontal(yellow,5);
                                };
                            //XOR
                            case 6:
                                switch (__gateOrientation__:@p[tag=lg.placing]) {
                                    case 0:
                                        this.apply_data.gates.vertical(orange,6);
                                    case 1:
                                        this.apply_data.gates.horizontal(orange,6);
                                };

                                
                        }

                    }

                    else {tag @s add lg.uiElement;}
                }
                tag @s remove lg.placing;
            } else if (items entity @s weapon.mainhand #c:shulker_boxes[!custom_data~{"lg.chip":1b}]) {
                __cpp__:@s := (__cpp__:@s + 1) % 3;
                __crp__:@s = -1;
                __crop__:@s = -1;
                if (__cpp__:@s = 0) {
                    __pp0__:@s = ui::highlightPos[0] * 100;
                    __pp1__:@s = ui::highlightPos[1] * 100;
                    __pp2__:@s = ui::highlightPos[2] * 100;

                    tellraw @s "Set Point 1";
                } else if (__cpp__:@s = 1) {

                    __pp3__:@s = ui::highlightPos[0] * 100;
                    __pp4__:@s = ui::highlightPos[1] * 100;
                    __pp5__:@s = ui::highlightPos[2] * 100;

                    tellraw @s "Set Point 2. Right click to confirm.";
                } else {
                    tag @s add lg.saving;
                    $chipStart_x = __pp0__:@s;
                    $chipStart_y = __pp1__:@s;
                    $chipStart_z = __pp2__:@s;

                    if (__pp0__:@s > __pp3__:@s) {__pp0__:@s >< __pp3__:@s;}
                    if (__pp1__:@s > __pp4__:@s) {__pp1__:@s >< __pp4__:@s;}
                    if (__pp2__:@s > __pp5__:@s) {__pp2__:@s >< __pp5__:@s;}
                    
                    $packVolume = 0;

                    $min_x = __pp0__:@s;
                    $min_y = __pp1__:@s;
                    $min_z = __pp2__:@s;
                    $max_x = __pp3__:@s;
                    $max_y = __pp4__:@s;
                    $max_z = __pp5__:@s;
                    
                    $build = 0;
                    $chip_num = 0;
                    $min_gateId = intLimit;
                    $min_wireId = intLimit;
                    $chipId++;
                    $yaw = _highlight_::Rotation[0];
                    $min_gateId < __gateId__:@e[type=block_display,tag=lg.uiElement,tag=lg.gate_output,distance=..250];
                    $min_wireId < __wireId__:@e[type=block_display,tag=lg.uiElement,tag=lg.hasWireId,tag=!lg.gate_input,distance=..250];
                    
                    $min_wireId--;

                    debug({score:{name:"$min_wireId",objective:"__variable__"}});
                    debug({score:{name:"$min_gateId",objective:"__variable__"}});
                    $recur = execute if entity @e[type=block_display,tag=lg.uiElement,distance=..250,predicate=mclg:between_points];
                    tag @e[type=block_display,tag=lg.uiElement,distance=..250,predicate=mclg:between_points] add lg.chip_build;

                    execute as @e[type=block_display,tag=lg.uiElement,tag=lg.chip_build,distance=..250,limit = 1000] run {
                        $build := ($build + 1) % 1000;
                        $packVolume++;
                        debug({"score":{"name":"$build","objective":"__variable__"}});

                        if ($build != 0) {
                            this.chip.store_data();

                            if ($packVolume = $recur) {
                                debug("Finished building chip");
                                this.chip.give_item();
                            }

                        } else {
                            debug("1000");
                            this.chip.store_data();
                            this.chip.give_item();
                            schedule function this.chip.build() 5t replace;
                        }
                    }
                }
            } else if (items entity @s weapon.mainhand #c:shulker_boxes[custom_data~{"lg.chip":1b}]) {
                $selectedChipId = @s::SelectedItem.components.minecraft:custom_data.id;
                chip::place.arrs.del();
                execute run {
                    $chip::place.arrs << @s::Inventory[{components:{"minecraft:custom_data":{id:$(0)}}}].components."minecraft:custom_data".blocks;
                    $chip::place.arrs << @s::equipment[{components:{"minecraft:custom_data":{id:$(0)}}}].components."minecraft:custom_data".blocks;

                } with [$selectedChipId];
                $place = 0;
                $max_gateId = 0;
                $max_wireId = 0;
                execute as @e[type=block_display,tag=lg.uiElement,tag=lg.hasWireId,distance=..250] run $max_wireId > __wireId2__:@s;
                execute as @e[type=block_display,tag=lg.uiElement,tag=lg.gate,distance=..250] run $max_gateId > __gateId__:@s;
                $max_gateId++;
                    
                for ($i = chip::place.arrs; $i > 0; $i--) {
                    for ($j = chip::place.arrs[-1]; $j > 0; $j--) {
                        execute summon block_display run {
                            rotate @s ~ ~;
                            @s::block_state = chip::place.arrs[-1][-1].block_state;
                            @s::CustomName = chip::place.arrs[-1][-1].CustomName;
                            @s::transformation.scale = [0.25f, 0.25f, 0.25f];
                            @s::Tags = chip::place.arrs[-1][-1].Tags;
                            __wireType__:@s = chip::place.arrs[-1][-1].wireType;

                            if (entity @s[tag=lg.rod]) {
                                __rodRotation__:@s = chip::place.arrs[-1][-1].rotation;
                            } else if (entity @s[tag=lg.stair]) {
                                __stairRotation__:@s = chip::place.arrs[-1][-1].rotation;
                            } else if (entity @s[tag=lg.gate]) {
                                __gateId__:@s := {chip::place.arrs[-1][-1].rel_id.gate} + $max_gateId;

                                if (entity @s[tag=lg.gate_output]) {
                                    __gateType__:@s = chip::place.arrs[-1][-1].gateType;
                                    __connectedWireId1__:@s := {chip::place.arrs[-1][-1].rel_id.connectedWire.1} + $max_wireId;
                                    __connectedWireId2__:@s := {chip::place.arrs[-1][-1].rel_id.connectedWire.2} + $max_wireId;
                                }
                            } else if (entity @s[tag=lg.buffer]) {
                                $currcwid1 = chip::place.arrs[-1][-1].rel_id.connectedWire.1;
                                if ($currcwid1 > 0) {
                                    __connectedWireId1__:@s := $currcwid1 + $max_wireId;
                                }
                                
                            }
                            if (entity @s[tag=lg.permaStarter,tag=lg.buffer]) {tag @s add lg.starter;}
                            execute run {
                                $tp @s ^$(x) ^$(y) ^;
                                $yaw = _highlight_::Rotation[0];
                                if ($yaw = 0 || $yaw = 180) {@s::Pos[2] = _highlight_::Pos[2];} 
                                else {@s::Pos[0] = _highlight_::Pos[0];}

                            } with chip::place.arrs[-1][-1].rel_pos;

                            $x = __pos0__:@s = @s::Pos[0] * 100;
                            $y = __pos1__:@s = @s::Pos[1] * 100;
                            $z = __pos2__:@s = @s::Pos[2] * 100;
                            
                            tag @s add lg.chip_placing;
                                if (entity @n[type=block_display,tag=lg.uiElement,tag=!lg.chip_placing,predicate=mclg:place_uielement/at_current_cell]) {
                                    kill @s;
                                }
                            tag @s remove lg.chip_placing;
                            
                            if (entity @s[tag=lg.hasWireId]) {
                                $currwid = chip::place.arrs[-1][-1].rel_id.wire.1;
                                if ($currwid = 0) {
                                    __wireId__:@s = 0;
                                } else {
                                    __wireId__:@s := $currwid + $max_wireId;
                                }
                                
                                __wireId2__:@s := {chip::place.arrs[-1][-1].rel_id.wire.2} + $max_wireId;
                                
                            }
                        }
                        chip::place.arrs[-1][-1].del();
                    }
                    chip::place.arrs[-1].del();
                    
                }
                chip::place.arrs.del();  
            }
        }
        Advancement.revoke(@s, only, place_uielement/single);
    }
    function fill() {
        if (!entity _uiElement_ && !items entity @s weapon.mainhand #c:shulker_boxes && items entity @s weapon.mainhand *) {

            __cpp__:@s := (__cpp__:@s + 1) % 3;
            __crp__:@s = -1;
            __crop__:@s = -1;
            if (__cpp__:@s = 0) {
                ui::placePos = _highlight_::Pos;
                __pp0__:@s = ui::placePos[0] * 100;
                __pp1__:@s = ui::placePos[1] * 100;
                __pp2__:@s = ui::placePos[2] * 100;

                tellraw @s "Set Place Point 1";
            } else if (__cpp__:@s = 1) {
                ui::placePos = _highlight_::Pos;
                __pp3__:@s = ui::placePos[0] * 100;
                __pp4__:@s = ui::placePos[1] * 100;
                __pp5__:@s = ui::placePos[2] * 100;

                tellraw @s "Set Place Point 2. Right click to confirm.";
            } else {

                if (__pp0__:@s > __pp3__:@s) {__pp0__:@s >< __pp3__:@s;}
                if (__pp1__:@s > __pp4__:@s) {__pp1__:@s >< __pp4__:@s;}
                if (__pp2__:@s > __pp5__:@s) {__pp2__:@s >< __pp5__:@s;}
                
                $fillVolume = 0;
                tag @s add lg.placing;
                if (items entity @s weapon.mainhand #mclg:wires/rods) {

                    this.place_fill(()=>{
                        this.apply_data.rod();
                    });

                } else if (items entity @s weapon.mainhand #mclg:wires/stairs) {
                    
                    this.place_fill(()=>{
                        this.apply_data.stair();
                    });

                } else if (items entity @s weapon.mainhand #mclg:wires/bulbs) {
                    this.place_fill(()=>{
                        this.apply_data.bulb();
                    });

                } else if (items entity @s weapon.mainhand #mclg:wires/grates) {
                    this.place_fill(()=>{
                        this.apply_data.grate();
                    });
                    
                } else if (items entity @s weapon.mainhand minecraft:redstone_lamp){
                    this.place_fill(()=>{
                        this.apply_data.buffer();
                    });

                } else {
                    this.place_fill(()=>{
                        this.apply_data.general();
                    });
                }
                tag @s remove lg.placing;
                if ($fillVolume = 1) {printf("\nPlaced &<$fillVolume,italic> &<!italic>element");} 
                else {printf("\nPlaced &<$fillVolume,italic> &<!italic>elements");}
            }
        }

        Advancement.revoke(@s, only, place_uielement/fill);
    }
}
