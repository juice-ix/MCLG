Scoreboard.add(__outputId__);
Scoreboard.add(__runtimeTruthId1__);
Scoreboard.add(__runtimeTruthId2__);

Scoreboard.add(__storageTruthId1__);
Scoreboard.add(__storageTruthId2__);

Scoreboard.add(__compileTicks__);
Scoreboard.add(__compileTicksNeeded__);

Scoreboard.add(__crtm__);

Scoreboard.add(__rtm0__);
Scoreboard.add(__rtm1__);
Scoreboard.add(__rtm2__);
Scoreboard.add(__rtm3__);
Scoreboard.add(__rtm4__);
Scoreboard.add(__rtm5__);

new advancement (rtm.attack_ui) {
  "criteria": {
    "hit_interaction": {
      "trigger": "minecraft:player_hurt_entity",
      "conditions": {
        "player": [
          {
            "condition": "minecraft:any_of",
            "terms": [
              {
                "condition": "minecraft:entity_properties",
                "entity": "this",
                "predicate": {
                  "equipment": {
                    "offhand": {
                      "items": "minecraft:stick",
                      "components": {
                        "minecraft:custom_data": {
                          "lg.rtm": true
                        }
                      }
                    }
                  }
                }
              },
              {
                "condition": "minecraft:entity_properties",
                "entity": "this",
                "predicate": {
                  "equipment": {
                    "mainhand": {
                      "items": "minecraft:stick",
                      "components": {
                        "minecraft:custom_data": {
                          "lg.rtm": true
                        }
                      }
                    }
                  }
                }
              }
            ]
          }
        ]
      }
    }
  },
  "rewards": {
    "function": "mclg:zzz_/compile/rtm"
  }
}

new predicate(msid) {
    "condition": "minecraft:entity_scores",
        "entity": "this",
        "scores": {
        "__starterId__": {
            "min": {
                "type": "minecraft:score",
                    "target": {
                    "type": "minecraft:fixed",
                    "name": "$j"
                },
                "score": "__variable__"
            },
            "max": {
                "type": "minecraft:score",
                    "target": {
                    "type": "minecraft:fixed",
                        "name": "$j"
                },
                "score": "__variable__"
            }
        }
    }
}

new predicate(matching_rti1) {
    "condition": "minecraft:entity_scores",
        "entity": "this",
        "scores": {
        "__runtimeTruthId1__": {
            "min": {
                "type": "minecraft:score",
                    "target": {
                    "type": "minecraft:fixed",
                    "name": "$rTruthId"
                },
                "score": "__variable__"
            },
            "max": {
                "type": "minecraft:score",
                    "target": {
                    "type": "minecraft:fixed",
                    "name": "$rTruthId"
                },
                "score": "__variable__"
            }
        }
    }
}

new predicate(matching_rti2) {
    "condition": "minecraft:entity_scores",
        "entity": "this",
        "scores": {
        "__runtimeTruthId2__": {
            "min": {
                "type": "minecraft:score",
                    "target": {
                    "type": "minecraft:fixed",
                    "name": "$rTruthId"
                },
                "score": "__variable__"
            },
            "max": {
                "type": "minecraft:score",
                    "target": {
                    "type": "minecraft:fixed",
                    "name": "$rTruthId"
                },
                "score": "__variable__"
            }
        }
    }
}
Item.create(
    rtm,
    minecraft:stick,
    component = [
        custom_data = {lg.rtm:1b},
        item_name = "Runtime Manager"
    ]
);

function give_runtime_manager () {
    Item.give(rtm);
}

class zzz_.compile {
    function make_packed_inputs () {
        $n = execute if entity @e[type=block_display,tag=lg.starter,predicate=mclg:between_points,distance=..250];  
        $loop = true;

        compile::inputs = [];
        compile::counter = [];

        for ($i = 0; $i < $n; $i++) {
            compile::inputs << [];
            compile::counter << 0;
        }

        while ($loop) {
            
            for ($bit = 0; $bit < $n; $bit++) {
                execute run {

                    $compile::inputs[$(0)] << compile::counter[$(0)];
                } with [$bit];
            }

            $carry = 1;
            for ($bit = 0; $bit < $n; $bit++) {
                execute run {

                    $$temp = compile::counter[$(0)];
                    $sum := $temp + $carry;

                    $counter := $sum % 2;
                    $compile::counter[$(0)] = $counter;

                    $carry := $sum / 2;
                    if ($carry = 0) {$bit = $n;}

                } with [$bit];
            
            }

            if ($carry = 1) {$loop = false;}
        }

        compile::counter.del();
    }

    function make_packed_outputs () {
        compile::outputs = [];
        $outputId = 0;
        scoreboard players reset @e[type=block_display,tag=lg.hasWireId,distance=..250,scores={__outputId__ = 0..}] __outputId__;
        execute as @e[type=block_display,tag=lg.starter,predicate=mclg:between_points,distance=..250] run {
            __bit1__:@s = __output__:@s;
        }

        tag @e remove lg.output;
        execute as @e[type=block_display,tag=lg.hasWireId,tag=!lg.starter,tag=!lg.gate_input,predicate=mclg:between_points,distance=..250] run {
            $wireId = __wireId2__:@s;
            if (!entity @e[type=block_display,predicate=mclg:between_points,predicate=mclg:is_connected,distance=..250]) {
                __outputId__:@s = $outputId;
                tag @s add lg.output;
                compile::outputs << [];
                $outputId++;
            }
        }

        $nRows = compile::inputs[0];
        $nInputs = compile::inputs;

        for ($row = 0; $row < $nRows; $row++) {

            for ($i = 0; $i < $nInputs; $i++) {
                execute run {
                    $__output__:@n[type=block_display,tag=lg.starter,distance=..250,predicate=mclg:matching_starter_id] = compile::inputs[$(0)][$(1)];
                } with [$i, $row];
            }

            $cycle = 0;

            // Set starting gate bits
            tag @e[type=block_display,tag=lg.startsFlood,distance=..250] add lg.dirty;

            while (entity @e[type=block_display,tag=lg.dirty,distance=..250] && $cycle < $idFloodCycleLimit) {
                $cycle++;
                debug(["=========== Cycle ", {score:{name:"$cycle",objective:"__variable__"}}, " ===========\n"]);
                execute as @e[type=block_display,tag=lg.dirty,distance=..250] run {
                    
                    tag @s remove lg.dirty;

                    // Initialize the ticks score for finding input bits
                    $ticks = -1;

                    $gateId = __gateId__:@s;
                    if (entity @s[tag=lg.buffer]) {
                        debug(["---------", {color:white, text:" Buffer "}, "----------"]);
                        $wireId = __wireId__:@s;
                        execute as @n[type=block_display,tag=!lg.gate_input,distance=..250,predicate=mclg:matching_wire_id] run {$in = __output__:@s;}
                            
                        debug(["|                Bit: ", {score:{name:"$in",objective:"__variable__"}}, "               |"]);
                        __output__:@s := $in;
                        
                        if ($in = 0) {
                            @s::block_state.Properties.lit = "false";
                        } else {
                            @s::block_state.Properties.lit = "true";
                        }
                        $wireId = __wireId2__:@s;
                    } else {
                        // Compute
                        switch (__gateType__:@s) {

                            // AND
                            case 0:
                                debug(["-----------", {color:green, text:" AND "}, "-----------"]);
                                id_flood.get_binary_bits();
                                __output__:@s := __bit0__:@s * __bit1__:@s;
                                $wireId = __wireId2__:@s;

                            // NAND
                            case 1:
                                debug(["-----------", {color:light_purple, text:" NAND "}, "-----------"]);
                                id_flood.get_binary_bits();
                                __output__:@s := (__bit0__:@s * __bit1__:@s) * -1 + 1;
                                $wireId = __wireId2__:@s;

                            // Two input NOR gate
                            case 2:
                                debug(["-----------", {color:gray, text:" NOR "}, "-----------"]);   
                                id_flood.get_binary_bits();       
                                __output__:@s := ((__bit0__:@s + __bit1__:@s) - (__bit0__:@s * __bit1__:@s)) * -1 + 1;
                                $wireId = __wireId2__:@s;

                            // NOT gate
                            case 3:
                                debug(["-----------", {color:red, text:" NOT "}, "-----------"]);  

                                $wireId = __wireId__:@s;

                                execute as @n[type=block_display,tag=!lg.gate_input,distance=..250,predicate=mclg:matching_wire_id] run {
                                    $in = __output__:@s;
                                    debug(["|                 Bit: ", {score:{name:"$in",objective:"__variable__"}}]);
                                }       
                                __output__:@s := $in * -1 + 1;
                                $wireId = __wireId2__:@s;

                            // Two input OR gate
                            case 4:
                                debug(["-----------", {color:dark_aqua, text:" OR "}, "-----------"]);
                                id_flood.get_binary_bits();
                                __output__:@s := (__bit0__:@s + __bit1__:@s) - (__bit0__:@s * __bit1__:@s);
                                $wireId = __wireId2__:@s;
                                
                            // Two input XNOR gate
                            case 5:
                                debug(["-----------", {color:yellow, text:" XNOR "}, "-----------"]);
                                id_flood.get_binary_bits();
                                __output__:@s := (1 + __bit0__:@s + __bit1__:@s) % 2;
                                $wireId = __wireId2__:@s;

                            // Two input XOR gate
                            case 6:
                                debug(["-----------", {color:gold, text:" XOR "}, "-----------"]);
                                id_flood.get_binary_bits();
                                __output__:@s := (__bit0__:@s + __bit1__:@s) % 2;
                                $wireId = __wireId2__:@s;
                        }

                    }
                    
                    debug(["|              Output: ", {score:{name:"@s",objective:"__output__"}}, "              |", "\n--------------------------"]);

                    if (__prevOutput__:@s != __output__:@s) {tag @e[type=block_display,predicate=mclg:is_connected,predicate=mclg:between_points,distance=..250] add lg.dirty;}

                    __prevOutput__:@s = __output__:@s; 
                }
            }

            if ($cycle >= $idFloodCycleLimit) {
                tellraw @a "Circuit exceeded ID flood iteration limit (possible oscillation)";
                tag @e[type=block_display,tag=lg.dirty,distance=..250] remove lg.dirty;
                scoreboard players reset @e __prevOutput__;
            }

            execute as @e[type=block_display,tag=lg.output,distance=..250] run {
                execute run {
                    $compile::outputs[$(0)] << 0;
                    $compile::outputs[$(0)][-1] = __output__:@s;
                } with [__outputId__:@s];
            }
        }

        execute as @e[type=block_display,tag=lg.buffer,tag=lg.starter,predicate=mclg:between_points,distance=..250] run {
            __output__:@s = __bit1__:@s;
            if (__output__:@s = 0) {
                @s::block_state.Properties.lit = "false";
            } else {
                @s::block_state.Properties.lit = "true";
            }
        }
    }

    function rtm () {
        $id = __playerId__:@s;


        if (predicate {condition:"minecraft:entity_properties",entity:"this",predicate:{type_specific:{type:"minecraft:player",input:{sprint:1b,sneak:0b}}}}) {
            execute at _highlight_ as @n[tag=lg.buffer,distance=..0.001] run {
                $state = @s::block_state.Properties.lit;
                if ($state = 4) {
                    @s::block_state.Properties.lit = "false";
                    __output__:@s = 0;
                }
                if ($state = 5) {
                    @s::block_state.Properties.lit = "true";
                    __output__:@s = 1;
                }
            }
        }
        else if (predicate {condition:"minecraft:entity_properties",entity:"this",predicate:{type_specific:{type:"minecraft:player",input:{sprint:0b,sneak:1b}}}}) {
                
            execute at _highlight_ as @n[type=block_display,tag=lg.hasWireId,tag=!lg.gate_input,distance=..0.001] run {
                $wireId = __wireId2__:@s;

                if (entity @s[tag=lg.starter]) {
                    scoreboard players reset @s __starterId__;
                    tag @s remove lg.starter;
                    tag @e[type=block_display,distance=..250,predicate=mclg:is_connected] remove lg.startsFlood;
                    tellraw @a "Removed starter tag";

                    $loweredId = -1;
                    tag @e[type=block_display,tag=lg.starter,distance=..250] add lg.lowerId;

                    while (entity @e[type=block_display,tag=lg.lowerId,distance=..250]) {
                        $i = intLimit;
                        $i < __starterId__:@e[type=block_display,tag=lg.lowerId,distance=..250];
                        $loweredId++;
                        
                        execute as @e[type=block_display,tag=lg.lowerId,distance=..250,predicate=mclg:matching_starter_id] run {
                            tag @s remove lg.lowerId;
                            __starterId__:@s = $loweredId;
                        }
                    }
                } else if (entity @s[tag=lg.truth_table_input]) {
                    tag @s add lg.starter;
                    tag @e[type=block_display,distance=..250,predicate=mclg:is_connected] add lg.startsFlood;
                    tellraw @a "Added starter to truth table input";

                }
                else {
                    tag @s add lg.starter;
                    __starterId__:@s = -1;
                    tag @e[type=block_display,distance=..250,predicate=mclg:is_connected] add lg.startsFlood;
                    tellraw @a "Added starter tag";

                    $max = -2;
                    $max > __starterId__:@e[type=block_display,tag=lg.starter,distance=..250];
                    $max++;
                    __starterId__:@s = $max;
                }
            }
        }
        else if (predicate {condition:"minecraft:entity_properties",entity:"this",predicate:{type_specific:{type:"minecraft:player",input:{sprint:1b,sneak:1b}}}}) {
            if ($currInput < $nTTInputs) {
                execute at _highlight_ as @n[type=block_display,tag=lg.uiElement,tag=lg.hasWireId,tag=!lg.gate_input,distance=..0.001] run {
                    tag @s add lg.truth_table_input;
                    __starterId__:@s = $currInput;
                    __runtimeTruthId2__:@s = $runtimeTruthId;
                    __storageTruthId2__:@s = $truthId;
                    __compileTicksNeeded__:@s = $nTTInputs;
                    $currInput++;
                }

            } else if ($currInput >= $nTTInputs && $currOutput < $nTTOutputs) {
                execute at _highlight_ as @n[type=block_display,tag=lg.uiElement,tag=lg.hasWireId,tag=!lg.gate_input,distance=..0.001] run {
                    tag @s add lg.truth_table_output;
                    __outputId__:@s = $currOutput;
                    __runtimeTruthId1__:@s = $runtimeTruthId;
                    __storageTruthId1__:@s = $truthId;
                    $currOutput++;
                }
            }
        }
        else {
            __crtm__:@s := (__crtm__:@s + 1) % 3;
            if (__crtm__:@s = 0) {
                ui::compilePos = _highlight_::Pos;
                __rtm0__:@s = ui::compilePos[0] * 100;
                __rtm1__:@s = ui::compilePos[1] * 100;
                __rtm2__:@s = ui::compilePos[2] * 100;

                tellraw @s "Set Truth Table Point 1";
            } else if (__crtm__:@s = 1) {
                ui::compilePos = _highlight_::Pos;
                __rtm3__:@s = ui::compilePos[0] * 100;
                __rtm4__:@s = ui::compilePos[1] * 100;
                __rtm5__:@s = ui::compilePos[2] * 100;

                tellraw @s "Set Truth Table Point 2.";
            } else {

                if (__rtm0__:@s > __rtm3__:@s) {__rtm0__:@s >< __rtm3__:@s;}
                if (__rtm1__:@s > __rtm4__:@s) {__rtm1__:@s >< __rtm4__:@s;}
                if (__rtm2__:@s > __rtm5__:@s) {__rtm2__:@s >< __rtm5__:@s;}

                $removeVolume = 0;

                $min_x = __rtm0__:@s;
                $min_y = __rtm1__:@s;
                $min_z = __rtm2__:@s;
                $max_x = __rtm3__:@s;
                $max_y = __rtm4__:@s;
                $max_z = __rtm5__:@s;

                execute at _highlight_ run {
                    this.make_packed_inputs();
                    this.make_packed_outputs(); 
                }
                 
            }
        }

        Advancement.revoke(@s,only,rtm/attack_ui);
    }
}

function name_truth_table () {   
    compile::temp.inputs = compile::inputs;
    compile::temp.outputs = compile::outputs;
    compile::temp.truthId = $storageTruthId;
    $compile::temp.name = $(name);
    truth_tables::tables << compile::temp;

    compile::inputs.del();
    compile::outputs.del();
    compile::temp.del();
    $storageTruthId++;
}

function assign_truth_table () {
    $compile::temp = truth_tables::tables[{name:$(name)}];

    $nTTInputs = compile::temp.inputs;
    $nTTOutputs = compile::temp.outputs;
    $truthId = compile::temp.truthId;

    compile::temp.del();

    $currInput = 0;
    $currOutput = 0;

    $runtimeTruthId++;
    async while ($currInput < $nTTInputs) {
        if (!$prevInput = $currInput) {
            tellraw @a ["Setting Input ", {score:{name:"$currInput",objective:"__variable__"}}];
        }

        $prevInput = $currInput;
    } 1t;

    async while ($currOutput < $nTTOutputs) {

        if ($currInput >= $nTTInputs) {
            if (!$prevOutput = $currOutput) {
                tellraw @a ["Setting Output ", {score:{name:"$currOutput",objective:"__variable__"}}];
            }

            $prevOutput = $currOutput;
        }
        
    } 1t;
}

function compile_complete () {
    $id = __playerId__:@s;
    $iterations = 0;
    $cycle = 0;
    compile::runtime = [];

    execute at _highlight_ run {

        // Set starting gate bits
        tag @e[type=block_display,tag=lg.starter,distance=..250] add lg.dirty;

        compile::runtime = [];
        __compileTicks__:@e[type=block_display,tag=lg.truth_table_input,distance=..250] = 0;

        while (entity @e[type=block_display,tag=lg.dirty,distance=..250] && $cycle < $idFloodCycleLimit) {
            $cycle++;
            debug(["=========== Cycle ", {score:{name:"$cycle",objective:"__variable__"}}, " ===========\n"]);
            execute as @e[type=block_display,tag=lg.dirty,distance=..250] run {
                
                tag @s remove lg.dirty;

                // Initialize the ticks score for finding input bits
                $rTruthId = __runtimeTruthId2__:@s;
                __compileTicks__:@e[type=block_display,tag=lg.truth_table_input,distance=..250,predicate=mclg:matching_rti2]++;
                if (__compileTicks__:@s = __compileTicksNeeded__:@s) {
                    execute run {
                        $compile::runtime << {runtimeTruthId: $(0), storageTruthId: $(1)};
                    } with [__runtimeTruthId2__:@s, __storageTruthId2__:@s];
                }

                if (__prevOutput__:@s != __output__:@s) {tag @e[type=block_display,predicate=mclg:matching_rti1,tag=!lg.dirty,distance=..250] add lg.dirty;}
            }
        }

        if ($cycle >= $idFloodCycleLimit) {
            tellraw @a "Circuit exceeded ID flood iteration limit (possible oscillation)";
            tag @e[type=block_display,tag=lg.dirty] remove lg.dirty;
            scoreboard players reset @e __prevOutput__;
        }
    }
}

function storage_flood () {
    $nTruthTables = compile::runtime;
    $id = __playerId__:@s;

    execute at _highlight_ run {
        for ($i = 0; $i < $nTruthTables; $i++) {
            execute run {
                $compile::temp = compile::runtime[$(0)];
                $sTruthId = compile::temp.storageTruthId;
                $rTruthId = compile::temp.runtimeTruthId;
            } with [$i];
            
            execute run {
                $$nInputs = truth_tables::tables[{truthId:$(0)}].inputs;
            } with [$sTruthId];

            $index = 0;
            $nInputs--;

            execute as @e[type=block_display,tag=lg.truth_table_input,distance=..250,predicate=mclg:matching_rti2] run {
                $power_index := $nInputs - __starterId__:@s;
                execute run {
                    $$power = math::pow2[$(0)];
                } with [$power_index];

                $index_add := __output__:@s * $power;
                $index += $index_add;
            }

            execute as @e[type=block_display,tag=lg.truth_table_output,distance=..250,predicate=mclg:matching_rti1] run {
                execute run {
                    $__output__:@s = truth_tables::tables[{truthId:$(0)}].outputs[$(1)][$(2)];
                    if (entity @s[tag=lg.buffer]) {
                        if (__output__:@s = 0) {
                            @s::block_state.Properties.lit = "false";
                        } else {
                            @s::block_state.Properties.lit = "true";
                        }
                    }
                } with [$sTruthId, __outputId__:@s, $index];
            } 
        }
    }
}