Scoreboard.add(__output__);
Scoreboard.add(__prevOutput__);
Scoreboard.add(__bit0__); Scoreboard.add(__bit1__); 

new predicate(matching_wire_id) {
    "condition": "minecraft:entity_scores",
        "entity": "this",
        "scores": {
        "__wireId2__": {
            "min": {
                "type": "minecraft:score",
                    "target": {
                    "type": "minecraft:fixed",
                    "name": "$wireId"
                },
                "score": "__variable__"
            },
            "max": {
                "type": "minecraft:score",
                    "target": {
                    "type": "minecraft:fixed",
                        "name": "$wireId"
                },
                "score": "__variable__"
            }
        }
    }
}

new predicate(matching_gate_id) {
    "condition": "minecraft:entity_scores",
        "entity": "this",
        "scores": {
        "__gateId__": {
            "min": {
                "type": "minecraft:score",
                    "target": {
                    "type": "minecraft:fixed",
                    "name": "$gateId"
                },
                "score": "__variable__"
            },
            "max": {
                "type": "minecraft:score",
                    "target": {
                    "type": "minecraft:fixed",
                        "name": "$gateId"
                },
                "score": "__variable__"
            }
        }
    }
}

new predicate(is_connected) {
  "condition": "minecraft:any_of",
  "entity": "this",
  "terms": [
    {
      "entity": "this",
      "scores": {
        "__connectedWireId1__": {
          "min": {
            "type": "minecraft:score",
            "target": {
              "type": "minecraft:fixed",
              "name": "$wireId"
            },
            "score": "__variable__"
          },
          "max": {
            "type": "minecraft:score",
            "target": {
              "type": "minecraft:fixed",
              "name": "$wireId"
            },
            "score": "__variable__"
          }
        }
      },
      "condition": "minecraft:entity_scores"
    },
    {
      "entity": "this",
      "scores": {
        "__connectedWireId2__": {
          "min": {
            "type": "minecraft:score",
            "target": {
              "type": "minecraft:fixed",
              "name": "$wireId"
            },
            "score": "__variable__"
          },
          "max": {
            "type": "minecraft:score",
            "target": {
              "type": "minecraft:fixed",
              "name": "$wireId"
            },
            "score": "__variable__"
          }
        }
      },
      "condition": "minecraft:entity_scores"
    }
  ]
}

@lazy function id_flood.get_binary_bits () {

    execute as @e[type=block_display,tag=lg.gate_input,distance=..26,predicate=mclg:matching_gate_id] run {
        $ticks++;

        $in = 0;
        $wireId = __wireId__:@s;
        execute as @n[type=block_display,tag=!lg.noOutput,distance=..250,predicate=mclg:matching_wire_id] run {
            $in = __output__:@s;
        }

        if ($ticks = 0) {
            __bit0__:@n[type=block_display,tag=lg.gate_output,distance=..250,predicate=mclg:matching_gate_id] = $in;
            debug(["|               Bit 0: ", {score:{name:"$in",objective:"__variable__"}}, "               |"]);
        } else if ($ticks = 1) {
            __bit1__:@n[type=block_display,tag=lg.gate_output,distance=..250,predicate=mclg:matching_gate_id] = $in;
            debug(["|               Bit 1: ", {score:{name:"$in",objective:"__variable__"}}, "               |"]);
        }
    }
    
}

function id_flood () {
    $id = __playerId__:@s;
    $iterations = 0;
    $cycle = 0;
    execute at _highlight_ run {

        // Set starting gate bits
        tag @e[type=block_display,tag=lg.starter,distance=..250] add lg.dirty;
        tag @e[type=block_display,tag=lg.buffer] remove lg.bufferHasOutput;

        while (entity @e[type=block_display,tag=lg.dirty,distance=..250] && $cycle < $idFloodCycleLimit) {
            $cycle++;
            debug(["=========== Cycle ", {score:{name:"$cycle",objective:"__variable__"}}, " ===========\n"]);
            execute as @e[type=block_display,tag=lg.dirty,distance=..250] run {
                
                tag @s remove lg.dirty;

                if (entity @s[tag=lg.truth_table_input]) {
                    $wireId = __wireId__:@s;

                    debug(["---------", {color:white, text:" Truth Table Input "}, "----------"]);
                    __output__:@s = __output__:@n[type=block_display,tag=!lg.noOutput,distance=..250,predicate=mclg:matching_wire_id];
                    
                    if (entity @s[tag=lg.buffer]) {
                        if (__output__:@s = 0) {
                            @s::block_state.Properties.lit = "false";
                        } else {
                            @s::block_state.Properties.lit = "true";
                        }
                    }

                    $rTruthId = __runtimeTruthId2__:@s;
                    $nInputs = __truthInputCount__:@s;
                    $outputIndex = 0;
                    $sameCount = 0;
                    
                    execute as @e[type=block_display,tag=lg.truth_table_input,distance=..250,predicate=mclg:matching_rti2] run {
                        if (__prevOutput__:@s = __output__:@s) {
                            $sameCount++;
                        }
                        $indexAdd :=  __output__:@s * __truthPower__:@s;
                        $outputIndex += $indexAdd;
                    }
                    
                    if (!$sameCount = $nInputs) {
                        execute as @e[type=block_display,tag=lg.truth_table_output,distance=..250,predicate=mclg:matching_rti1] run {
                            execute run {
                                $__output__:@s = truth_tables::tables[$(0)].outputs[$(1)][$(2)];
                                if (__prevOutput__:@s != __output__:@s) {
                                    $wireId = __wireId2__:@s;
                                    if (entity @s[tag=lg.buffer]) {
                                        if (__output__:@s = 0) {
                                            @s::block_state.Properties.lit = "false";
                                        } else {
                                            @s::block_state.Properties.lit = "true";
                                        }
                                    }
                                    tag @e[type=block_display,predicate=mclg:is_connected,distance=..250] add lg.dirty;
                                }
                                __prevOutput__:@s = __output__:@s; 
                                
                            } with [__storageTruthIndex1__:@s, __truthOutputId__:@s, $outputIndex];
                        } 
                    }
                    
                    __prevOutput__:@s = __output__:@s;
                } else if (entity @s[tag=lg.buffer]) {
                    debug(["---------", {color:white, text:" Buffer "}, "----------"]);
                    $wireId = __wireId__:@s;
                    __output__:@s = __output__:@n[type=block_display,tag=!lg.noOutput,distance=..250,predicate=mclg:matching_wire_id];
                        
                    debug(["|                Bit: ", {score:{name:"@s",objective:"__output__"}}, "               |"]);
                    
                    if (__output__:@s = 0) {
                        @s::block_state.Properties.lit = "false";
                    } else {
                        @s::block_state.Properties.lit = "true";
                    }
                    $wireId = __wireId2__:@s;
                } else if (entity @s[tag=lg.target]) {
                    debug(["---------", {color:white, text:" Target "}, "----------"]);
                    $wireId = __wireId__:@s;
                    __output__:@s = 0;
                    __output__:@s = __output__:@n[type=block_display,tag=!lg.noOutput,distance=..250,predicate=mclg:matching_wire_id];
                        
                    debug(["|                Bit: ", {score:{name:"@s",objective:"__output__"}}, "               |"]);
                    $wireId = __wireId2__:@s;
                } else {
                    $ticks = -1;
                    $gateId = __gateId__:@s;
                    // Compute
                    switch (__gateType__:@s) {

                        // AND
                        case 0:
                            debug(["-----------", {color:green, text:" AND "}, "-----------"]);
                            id_flood.get_binary_bits();
                            __output__:@s := __bit0__:@s * __bit1__:@s;
                            $wireId = __wireId2__:@s;

                        // NAND
                        case 1:
                            debug(["-----------", {color:light_purple, text:" NAND "}, "-----------"]);
                            id_flood.get_binary_bits();
                            __output__:@s := (__bit0__:@s * __bit1__:@s) * -1 + 1;
                            $wireId = __wireId2__:@s;

                        // Two input NOR gate
                        case 2:
                            debug(["-----------", {color:gray, text:" NOR "}, "-----------"]);   
                            id_flood.get_binary_bits();       
                            __output__:@s := ((__bit0__:@s + __bit1__:@s) - (__bit0__:@s * __bit1__:@s)) * -1 + 1;
                            $wireId = __wireId2__:@s;

                        // NOT gate
                        case 3:
                            debug(["-----------", {color:red, text:" NOT "}, "-----------"]);  

                            $wireId = __wireId__:@s;
                            __output__:@s = 0;
                            __output__:@s = __output__:@n[type=block_display,tag=!lg.noOutput,distance=..250,predicate=mclg:matching_wire_id];
                            debug(["|                 Bit: ", {score:{name:"@s",objective:"__output__"}}]);

                            __output__:@s *= -1;
                            __output__:@s += 1;
                            $wireId = __wireId2__:@s;
                        // Two input OR gate
                        case 4:
                            debug(["-----------", {color:dark_aqua, text:" OR "}, "-----------"]);
                            id_flood.get_binary_bits();
                            __output__:@s := (__bit0__:@s + __bit1__:@s) - (__bit0__:@s * __bit1__:@s);
                            $wireId = __wireId2__:@s;
                            
                        // Two input XNOR gate
                        case 5:
                            debug(["-----------", {color:yellow, text:" XNOR "}, "-----------"]);
                            id_flood.get_binary_bits();
                            __output__:@s := (1 + __bit0__:@s + __bit1__:@s) % 2;
                            $wireId = __wireId2__:@s;

                        // Two input XOR gate
                        case 6:
                            debug(["-----------", {color:gold, text:" XOR "}, "-----------"]);
                            id_flood.get_binary_bits();
                            __output__:@s := (__bit0__:@s + __bit1__:@s) % 2;
                            $wireId = __wireId2__:@s;
                    }

                }
                
                debug(["|              Output: ", {score:{name:"@s",objective:"__output__"}}, "              |", "\n--------------------------"]);

                if (__prevOutput__:@s[tag=!lg.bufferHasOutput] != __output__:@s[tag=!lg.bufferHasOutput]) {
                    tag @e[type=block_display,predicate=mclg:is_connected,distance=..250] add lg.dirty;
                    if (entity @s[tag=lg.buffer] || entity @s[tag=lg.target]) {tag @s add lg.bufferHasOutput;}
                }

                __prevOutput__:@s = __output__:@s; 
            }
        }

        compile::temp.del();
        if ($cycle >= $idFloodCycleLimit) {
            tellraw @a "Circuit exceeded ID flood iteration limit (possible oscillation)";
            tag @e[type=block_display,tag=lg.dirty] remove lg.dirty;
            scoreboard players reset @e __prevOutput__;
        }
    }
}