Scoreboard.add(__ticks__);
Scoreboard.add(__bit1__); Scoreboard.add(__bit2__);
Scoreboard.add(__prevBit1__); Scoreboard.add(__prevBit2__);
Scoreboard.add(__prevOutput__);
Scoreboard.add(__repeatBit__);

new predicate(matching_wire_id) {
    "condition": "minecraft:entity_scores",
        "entity": "this",
        "scores": {
        "__wireId__": {
            "min": {
                "type": "minecraft:score",
                    "target": {
                    "type": "minecraft:fixed",
                    "name": "$wireId"
                },
                "score": "__variable__"
            },
            "max": {
                "type": "minecraft:score",
                    "target": {
                    "type": "minecraft:fixed",
                        "name": "$wireId"
                },
                "score": "__variable__"
            }
        }
    }
}

new predicate(matching_gate_id) {
    "condition": "minecraft:entity_scores",
        "entity": "this",
        "scores": {
        "__gateId__": {
            "min": {
                "type": "minecraft:score",
                    "target": {
                    "type": "minecraft:fixed",
                    "name": "$gateId"
                },
                "score": "__variable__"
            },
            "max": {
                "type": "minecraft:score",
                    "target": {
                    "type": "minecraft:fixed",
                        "name": "$gateId"
                },
                "score": "__variable__"
            }
        }
    }
}

function id_flood () {
    $id = __playerId__:@s;
    execute positioned as _highlight_ run { 

        // Reset last run
        tag @e[type=block_display,tag=lg.uiElement,distance=..250,tag=lg.hasWireId,tag=lg.new_flood] remove lg.new_flood;
        __ticks__:@e[type=block_display,tag=lg.uiElement,tag=lg.gate_output,distance=..250,tag=lg.hasWireId] = 0;
        __prevBit1__:@e[type=block_display,tag=lg.uiElement,tag=lg.gate_output,distance=..250,tag=lg.hasWireId,scores={__prevBit1__=0..}] = -1;
        __prevBit2__:@e[type=block_display,tag=lg.uiElement,tag=lg.gate_output,distance=..250,tag=lg.hasWireId,scores={__prevBit2__=0..}] = -1;
        __prevOutput__:@e[type=block_display,tag=lg.uiElement,tag=lg.gate_output,distance=..250,tag=lg.hasWireId,scores={__prevOutput__=0..}] = -1;

        execute as @e[type=block_display,tag=lg.uiElement,tag=lg.buffer,tag=lg.starter,distance=..250] run {

            // Add flooded tag to ensure it doesn't get run twice
            $wireId = __wireId__:@s;
            
            // Check whether the lamp is on (bit = 0) or the lamp is off (bit = 1)
            $bit = @s::block_state.Properties.lit;
            if ($bit = 4) {$bit = 1;}
            if ($bit = 5) {$bit = 0;}
            debug(["Output: ", {"score":{"name":"$bit","objective":"__variable__"}}]);

            // Find connected gate inputs
            execute as @e[type=block_display,tag=lg.uiElement,tag=lg.gate_input,distance=..250,predicate=mclg:matching_wire_id] at @s run {
                $gateId = __gateId__:@s;
                
                // Find the gate output(s)
                execute as @e[type=block_display,tag=lg.uiElement,tag=lg.gate_output,distance=..0.26,predicate=mclg:matching_gate_id] run {

                    // Tick as many times as defined. Each tick sets a new bit scoreboard 
                    // E.g. tick 1 = __bit1__, tick 2 = __bit2__
                    __ticks__:@s++;
                    if (__ticks__:@s != __ticksNeeded__:@s) {
                        execute run {
                            $scoreboard players operation @s __bit$(0)__ = $bit __variable__;
                            $scoreboard players operation @s __prevBit$(0)__ = $bit __variable__;
                        } with [__ticks__:@s];

                    } else {
                    execute run {
                            $scoreboard players operation @s __bit$(0)__ = $bit __variable__;
                            tag @s add lg.new_flood;
                        } with [__ticks__:@s];
                    }
                }
            }

            // Find connected lamps and set their lit state depending on the current bit
            execute as @e[type=block_display,tag=lg.uiElement,distance=..250,tag=lg.buffer,tag=!lg.starter,predicate=mclg:matching_wire_id] run {
                if ($bit = 1) {@s::block_state.Properties.lit = "true";}
                if ($bit = 0) {@s::block_state.Properties.lit = "false";}
            }
        }

        // If any fully ticked gates were found, continue
        if (entity @e[type=block_display,tag=lg.uiElement,tag=lg.hasWireId,tag=lg.new_flood,distance=..250]) {
            zzz_.id_flood.promote();
        }
    }
}

function zzz_.id_flood.promote () {
    execute as @e[type=block_display,tag=lg.uiElement,tag=lg.new_flood,distance=..250] run {

        // Check the gate type and do appropiate math
        switch (__gateType__:@s) {
            // Two Input AND gate
            case 0:
                debug("AND");
                $bit := __bit1__:@s * __bit2__:@s; 

            // Two input NAND gate
            case 1:
                debug("NAND");
                $bit := (__bit1__:@s * __bit2__:@s) * -1 + 1;

            // Two input NOR gate
            case 2:
                debug("NOR");            
                $bit := ((__bit1__:@s + __bit2__:@s) - (__bit1__:@s * __bit2__:@s)) * -1 + 1;

            // NOT gate
            case 3:
                debug("NOT");            
                $bit := __bit1__:@s * -1 + 1; 
            

            // Two input OR gate
            case 4:
                debug("OR");
                $bit := (__bit1__:@s + __bit2__:@s) - (__bit1__:@s * __bit2__:@s);

            // Two input XNOR gate
            case 5:
                debug("XNOR");
                $bit = execute if score @s __bit1__ = @s __bit2__;

            // Two input XOR gate
            case 6:
                debug ("XOR"); 
                $bit = execute unless score @s __bit1__ = @s __bit2__;             
        }

        debug(["Bit 1: ", {"score":{"name":"@s","objective":"__bit1__"}}, " | Previous bit 1: ", {"score":{"name":"@s","objective":"__prevBit1__"}}]); 
        debug(["Bit 2: ", {"score":{"name":"@s","objective":"__bit2__"}}, " | Previous bit 2: ", {"score":{"name":"@s","objective":"__prevBit2__"}}]); 
        debug(["Output: ", {"score":{"name":"$bit","objective":"__variable__"}}]);

        // Add flooded tag to ensure it doesn't get flooded twice
        tag @s remove lg.new_flood;
        $wireId = __wireId__:@s;

        if ($bit = __prevOutput__:@s) {
            tag @s remove lg.can_repeat;
            __ticks__:@s = 2;
        } else {
            tag @s add lg.can_repeat;

            if (__bit1__:@s = __prevBit1__:@s) {__repeatBit__:@s = 2;}
            else if (__bit2__:@s = __prevBit2__:@s) {__repeatBit__:@s = 1;}

            // Check for connected gates with the same method as before
            execute as @e[type=block_display,tag=lg.uiElement,tag=lg.gate_input,distance=..250,predicate=mclg:matching_wire_id] at @s run {
                $gateId = __gateId__:@s;

                execute as @n[type=block_display,tag=lg.uiElement,tag=lg.gate_output,distance=..0.26,predicate=mclg:matching_gate_id] run {  
                    __ticks__:@s++;              
                    if (entity @s[tag=lg.can_repeat] && __ticks__:@s > __ticksNeeded__:@s) {
                        switch (__repeatBit__:@s) {
                            case 1:
                                __bit1__:@s = $bit;
                                debug("Repeating Bit 1");
                            case 2:
                                __bit2__:@s = $bit;
                                debug("Repeating Bit 2");
                        }

                        tag @s add lg.new_flood;
                    } else {
                        if (__ticks__:@s != __ticksNeeded__:@s) {
                        execute run {
                            $scoreboard players operation @s __bit$(0)__ = $bit __variable__;
                        } with [__ticks__:@s];

                        } else {
                        execute run {
                                $scoreboard players operation @s __bit$(0)__ = $bit __variable__;
                                tag @s add lg.new_flood;
                            } with [__ticks__:@s];
                        }
                    }
                }
            }
        }
        // Check for connected buffers with the same method as before
        execute as @e[type=block_display,tag=lg.uiElement,tag=lg.buffer,distance=..250,predicate=mclg:matching_wire_id] run {
            if ($bit = 1) {@s::block_state.Properties.lit = "true"; debug("LAMP: Setting bit to 1");}
            if ($bit = 0) {@s::block_state.Properties.lit = "false"; debug("LAMP: Setting bit to 0");}
        }

        __prevBit1__:@s = __bit1__:@s;
        __prevBit2__:@s = __bit2__:@s;
        __prevOutput__:@s = $bit;
    }

    // If there are any conncted gates, loop
    if (entity @e[type=block_display,tag=lg.uiElement,tag=lg.hasWireId,tag=lg.new_flood]) {
        zzz_.id_flood.promote();
    }
}